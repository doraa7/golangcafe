その１
エラーは最初にチェックして深いネストを避けよう！
　　コンパイルしたら、同じようなコードになるんだろうけど、人間が見やすいかどうかが重要

その２
Writerとエラー、サイズなどを構造体に入れ、構造体内部で管理しよう！
　　構造体のエラーがあれば、何もせず処理を抜ける。
　　そうすることで、呼び出し側はWrite()するだけで済む。

その３
型によって処理が決まる場合は、型で処理を分岐させましょう！
　　引数をinterface{}で受け取り、switch文のv.(type)を使って、処理を分ける。
　　そうすることで、呼び出し側はキャストが不要になるし、コードも見やすくなる。

その４
switch文の:=の定義を使え！
　　型によって分岐させる時に、:=を使うと、値の取得と型の判定が両方できるようになる。
　　case文は型で判定され、xには、Type Assertion後の値が入る。

その５
全て書くか、なにも書かないかのどちらかにする。
　　bytes.Bufferに全ての書き込みデータを貯めておき、Flush()で実際に出力する。
　　今回のWrite()は再起呼び出しを使って、バッファへの出力を行っている。

その６
リクエストを処理し、エラーを返す関数と、エラーを受け取り、エラーを処理する関数に分ける！
　　複数の処理でエラーチェックを行うのではなく、エラーを戻り値として返し、エラー処理は1か所のまとめると見やすくなる。

